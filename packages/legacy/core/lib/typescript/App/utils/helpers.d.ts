import { AnonCredsCredentialInfo, AnonCredsCredentialsForProofRequest, AnonCredsProofRequest, AnonCredsProofRequestRestriction, AnonCredsRequestedAttributeMatch, AnonCredsRequestedPredicateMatch } from '@credo-ts/anoncreds';
import { Agent, BasicMessageRecord, BaseLogger, ConnectionRecord, CredentialExchangeRecord, ProofExchangeRecord, OutOfBandRecord } from '@credo-ts/core';
import { Predicate } from '@hyperledger/aries-oca/build/legacy';
import { ReactNode } from 'react';
import { TFunction } from 'react-i18next';
import { Role } from '../types/chat';
import { ProofCredentialAttributes, ProofCredentialItems, ProofCredentialPredicates } from '../types/proof-items';
import { ChildFn } from '../types/tour';
import { BifoldAgent } from './agent';
export { parsedCredDefNameFromCredential } from './cred-def';
export { parsedCredDefName } from './cred-def';
export { parsedSchema } from './schema';
/**
 * Generates a numerical hash based on a given string
 * @see https://stackoverflow.com/questions/3426404/create-a-hexadecimal-colour-based-on-a-string-with-javascript
 * @param { string } s given string
 * @returns { number } numerical hash value
 */
export declare const hashCode: (s: string) => number;
/**
 * Converts a numerical hash into a hexidecimal color string
 * @see https://helderesteves.com/generating-random-colors-js/#Generating_random_dark_colors
 * @param { number } hash numerical hash value (generated by hashCode function above)
 * @returns { string } hexidecimal string eg. #32d3cc
 */
export declare const hashToRGBA: (hash: number) => string;
/**
 *
 * @param time
 * @param params see below
 * shortMonth: whether to use Jun in place of June, Mar in place of March for example (overridden by `format`)
 * format: an optional custom moment format string to create the formatted date from
 * includeHour: whether to add the hour and minute and am/pm. eg 9:32 pm (overridden by `chatFormat` and `trim`)
 * chatFormat: whether to style the date to appear like a chat message timestamp eg. '7 minutes ago' or 'Just now'
 * trim: if true, if it's the same day the date will be trimmed to just the hour, if it's the same year then the year will be trimmed from the date
 * eg. if the current year is 2023, February 12, 2023 will be trimmed to February 12
 * @returns formatted time string
 */
export declare function formatTime(time: Date, params?: {
    shortMonth?: boolean;
    format?: string;
    includeHour?: boolean;
    chatFormat?: boolean;
    trim?: boolean;
}): string;
export declare function b64encode(inp: string): string;
export declare function b64decode(b64: string): string;
export declare function formatIfDate(format: string | undefined, value: string | number | null): string | number | null;
export declare function getConnectionName(connection: ConnectionRecord | undefined, alternateContactNames: Record<string, string>): string;
export declare function useCredentialConnectionLabel(credential?: CredentialExchangeRecord): string;
export declare function useConnectionImageUrl(connectionId: string): string | undefined;
export declare function firstValidCredential(fields: AnonCredsRequestedAttributeMatch[] | AnonCredsRequestedPredicateMatch[], revoked?: boolean): AnonCredsRequestedAttributeMatch | AnonCredsRequestedPredicateMatch | null;
/**
 * A sorting function for the Array `sort()` function
 * @param a First retrieved credential
 * @param b Second retrieved credential
 */
export declare const credentialSortFn: (a: any, b: any) => number;
export declare const credDefIdFromRestrictions: (queries?: AnonCredsProofRequestRestriction[]) => string;
export declare const schemaIdFromRestrictions: (queries?: AnonCredsProofRequestRestriction[]) => string;
export declare const isDataUrl: (value: string | number | null) => boolean;
export type Fields = Record<string, AnonCredsRequestedAttributeMatch[] | AnonCredsRequestedPredicateMatch[]>;
/**
 * Retrieve current credentials info filtered by `credentialDefinitionId` if given.
 * @param credDefId Credential Definition Id
 * @returns Array of `AnonCredsCredentialInfo`
 */
export declare const getCredentialInfo: (credId: string, fields: Fields) => AnonCredsCredentialInfo[];
/**
 * Given proof credential items, evaluate and return its predicates, setting `satisfied` property.
 * @param proofCredentialsItems
 * @returns Array of evaluated predicates
 */
export declare const evaluatePredicates: (fields: Fields, credId?: string) => (proofCredentialItems: ProofCredentialItems) => Predicate[];
export declare const processProofAttributes: (request?: AnonCredsProofRequest, credentials?: AnonCredsCredentialsForProofRequest, credentialRecords?: CredentialExchangeRecord[], groupByReferent?: boolean) => {
    [key: string]: ProofCredentialAttributes;
};
export declare const mergeAttributesAndPredicates: (attributes: {
    [key: string]: ProofCredentialAttributes;
}, predicates: {
    [key: string]: ProofCredentialPredicates;
}) => {
    [key: string]: ProofCredentialAttributes & ProofCredentialPredicates;
};
export declare const processProofPredicates: (request?: AnonCredsProofRequest, credentials?: AnonCredsCredentialsForProofRequest, credentialRecords?: CredentialExchangeRecord[], groupByReferent?: boolean) => {
    [key: string]: ProofCredentialPredicates;
};
export declare const retrieveCredentialsForProof: (agent: BifoldAgent, proof: ProofExchangeRecord, fullCredentials: CredentialExchangeRecord[], t: TFunction<'translation', undefined>, groupByReferent?: boolean) => Promise<{
    groupedProof: (ProofCredentialAttributes & ProofCredentialPredicates)[];
    retrievedCredentials: AnonCredsCredentialsForProofRequest;
    fullCredentials: CredentialExchangeRecord[];
    descriptorMetadata: import("./anonCredsProofRequestMapper").DescriptorMetadata;
} | {
    groupedProof: (ProofCredentialAttributes & ProofCredentialPredicates)[];
    retrievedCredentials: AnonCredsCredentialsForProofRequest | undefined;
    fullCredentials: CredentialExchangeRecord[];
    descriptorMetadata?: undefined;
} | undefined>;
export declare const pTypeToText: (item: Predicate, t: TFunction<'translation', undefined>, attributeTypes?: Record<string, string>) => {
    pValue: string | number | null;
    pType: string;
    parameterizable?: boolean | undefined;
    satisfied?: boolean | undefined;
    name: string;
    format?: string | undefined;
    type?: string | undefined;
    encoding?: string | undefined;
    mimeType?: string | undefined;
    revoked?: boolean | undefined;
    credentialId?: string | undefined;
    label?: string | undefined;
    restrictions?: AnonCredsProofRequestRestriction[] | undefined;
    nonRevoked?: import("@credo-ts/anoncreds").AnonCredsNonRevokedInterval | undefined;
};
/**
 * @deprecated The function should not be used
 */
export declare const sortCredentialsForAutoSelect: (credentials: AnonCredsCredentialsForProofRequest) => AnonCredsCredentialsForProofRequest;
/**
 * Useful for multi use invitations
 * @param agent an Agent instance
 * @param invitationId id of invitation
 */
export declare const removeExistingInvitationIfRequired: (agent: Agent | undefined, invitationId: string) => Promise<void>;
/**
 * Get a oob record and connection record from a URI using built-in Credo methods
 * @param uri a URI that is either a redirect URL or contains a base64 encoded connection invite in query params
 * @param agent an Agent instance
 * @param implicitInvitations a boolean to determine if implicit invitation behavior should be used
 * @param reuseConnection a boolean to determine if connection reuse should be allowed
 * @returns an object containing an OOB record and, if not connectionless, a connection record
 */
export declare const connectFromInvitation: (uri: string, agent: Agent | undefined, implicitInvitations?: boolean, reuseConnection?: boolean) => Promise<OutOfBandRecord>;
/**
 * Receive a message from a scan or deeplink and navigate accordingly
 * @param uri a URI either containing a base64 encoded connection invite in the query parameters or a redirect URL itself
 * @param agent an Agent instance
 * @param logger injected logger from DI container
 * @param navigation a navigation object from either the Scan screen, Home screen, or PasteUrl screen
 * @param isDeepLink a boolean to communicate where the uri is coming from
 * @param implicitInvitations a boolean to determine if implicit invitation behavior should be used
 * @param reuseConnection a boolean to determine if connection reuse should be allowed
 * @throws Error with message containing the primary and beta error messages if both fail
 */
export declare const connectFromScanOrDeepLink: (uri: string, agent: Agent | undefined, logger: BaseLogger, navigation: any, isDeepLink: boolean, implicitInvitations?: boolean, reuseConnection?: boolean) => Promise<void>;
/**
 * Create a new connection invitation
 *
 * @param agent an Agent instance
 * @param goalCode add goalCode to connection invitation
 * @returns a connection record
 */
export declare const createConnectionInvitation: (agent: Agent | undefined, goalCode?: string) => Promise<{
    record: OutOfBandRecord;
    invitation: import("@credo-ts/core").OutOfBandInvitation;
    invitationUrl: string;
}>;
/**
 * Create a new connection invitation with a goal code specifying that it will be deleted after issuing or verifying once depending on type
 *
 * @param agent an Agent instance
 * @param type add goalCode to connection invitation
 * @returns a connection record
 */
export declare const createTempConnectionInvitation: (agent: Agent | undefined, type: 'issue' | 'verify') => Promise<{
    record: OutOfBandRecord;
    invitation: import("@credo-ts/core").OutOfBandInvitation;
    invitationUrl: string;
}>;
/**
 * Typeguard to check if any React children is represented as a function
 * instead of a Node. I,e., when it's a {@link ChildFn}.
 *
 * @param children any React children
 * @returns true if the children is a function, false otherwise
 */
export declare function isChildFunction<T>(children: ReactNode | ChildFn<T>): children is ChildFn<T>;
export declare function getCredentialEventRole(record: CredentialExchangeRecord): Role;
export declare function getCredentialEventLabel(record: CredentialExchangeRecord): "" | "Chat.CredentialProposalSent" | "Chat.CredentialOfferReceived" | "Chat.CredentialRequestSent" | "Chat.CredentialDeclined" | "Chat.CredentialReceived";
export declare function getProofEventRole(record: ProofExchangeRecord): Role;
export declare function getProofEventLabel(record: ProofExchangeRecord): "" | "Chat.ProofRequestSent" | "Chat.ProofPresentationReceived" | "Chat.ProofRequestReceived" | "Chat.ProofRequestSatisfied" | "Chat.ProofRequestRejected" | "Chat.ProofRequestRejectReceived";
export declare function getMessageEventRole(record: BasicMessageRecord): Role;
export declare function generateRandomWalletName(): string;
//# sourceMappingURL=helpers.d.ts.map